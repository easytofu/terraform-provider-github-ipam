// Copyright (c) EasyTofu
// SPDX-License-Identifier: MPL-2.0

package ipam

import (
	"fmt"
	"net"
	"sort"
	"strings"
)

// PrivateRange represents a private IP address range.
type PrivateRange struct {
	Name       string
	CIDR       string
	StartIP    string
	EndIP      string
	TotalAddrs uint64
	PrefixLen  int
}

// Private IP ranges (RFC 1918)
var PrivateRanges = []PrivateRange{
	{Name: "Class A", CIDR: "10.0.0.0/8", StartIP: "10.0.0.0", EndIP: "10.255.255.255", TotalAddrs: 16777216, PrefixLen: 8},
	{Name: "Class B", CIDR: "172.16.0.0/12", StartIP: "172.16.0.0", EndIP: "172.31.255.255", TotalAddrs: 1048576, PrefixLen: 12},
	{Name: "Class C", CIDR: "192.168.0.0/16", StartIP: "192.168.0.0", EndIP: "192.168.255.255", TotalAddrs: 65536, PrefixLen: 16},
}

// GeneratedFiles holds all generated markdown files.
type GeneratedFiles struct {
	Files map[string]string // path -> content
}

// GenerateAllFiles generates the main README and all pool detail pages.
func GenerateAllFiles(pools *PoolsConfig, allocations *AllocationsDatabase) *GeneratedFiles {
	files := &GeneratedFiles{
		Files: make(map[string]string),
	}

	// Generate main README
	files.Files[".github/README.md"] = generateMainREADME(pools, allocations)

	// Generate pool detail pages
	if pools != nil && pools.Pools != nil {
		for poolName := range pools.Pools {
			path := fmt.Sprintf(".github/ipam/pools/%s.md", poolName)
			files.Files[path] = generatePoolPage(poolName, pools, allocations)
		}
	}

	return files
}

func generateMainREADME(pools *PoolsConfig, allocations *AllocationsDatabase) string {
	var sb strings.Builder

	sb.WriteString("# IP Address Space Overview\n\n")
	sb.WriteString("> ‚ö†Ô∏è&nbsp;&nbsp;**IMPORTANT**&nbsp;&nbsp;‚ö†Ô∏è<br>\n")
	sb.WriteString(">\n")
	sb.WriteString("> This documentation is automatically generated by the `easytofu/github-ipam` Terraform provider. Do not manually edit\n")
	sb.WriteString("> this page, changes will be overwritten when allocations are updated. For more information please view the Terraform\n")
	sb.WriteString("> provider registry at: https://registry.terraform.io/providers/easytofu/github-ipam/latest/docs\n\n")

	// Legend at the top
	sb.WriteString("| Status | Description |\n")
	sb.WriteString("|:-------|:------------|\n")
	sb.WriteString("| üîµ&nbsp;&nbsp;Allocated | In active use. Do not reclaim. |\n")
	sb.WriteString("| üü†&nbsp;&nbsp;Reserved | Saved for future projects. Contact Network Team. |\n")
	sb.WriteString("| ‚ö™&nbsp;&nbsp;Available | Free space. Safe to allocate. |\n\n")

	// Process each private range
	for _, pr := range PrivateRanges {
		poolsInRange := getPoolsInRange(pools, pr.CIDR)

		sb.WriteString(fmt.Sprintf("## %s Address Space (%s - %s)\n\n", pr.Name, pr.StartIP, pr.EndIP))

		if len(poolsInRange) == 0 {
			sb.WriteString("*No pools allocated*\n\n")
			continue
		}

		// Build block table for this range
		blocks := buildRangeBlocks(pr, poolsInRange, pools, allocations)

		// Render as table
		sb.WriteString("| Status | Pool Name | CIDR | Size | Allocated | Utilization |\n")
		sb.WriteString("|:-------|:----------|:-----|-----:|:----------|:------------|\n")

		var totalSize, totalAllocated uint64
		for _, block := range blocks {
			sb.WriteString(block.ToTableRow())
			totalSize += block.Size
			if block.Type == "pool" {
				totalAllocated += block.UsedAddrs
			}
		}

		// Summary row
		totalUtil := 0.0
		if totalSize > 0 {
			totalUtil = float64(totalAllocated) / float64(totalSize) * 100
		}
		classCIDR := fmt.Sprintf("`%s` (%s - %s)", pr.CIDR, pr.StartIP, pr.EndIP)
		sb.WriteString(fmt.Sprintf("| **Totals** | | %s | **%s** | **%s/%s (%.1f%%)** | **%s** |\n",
			classCIDR,
			formatNumber(totalSize),
			formatNumber(totalAllocated),
			formatNumber(totalSize),
			totalUtil,
			renderUtilBarOnly(totalUtil)))

		sb.WriteString("\n")

		// Generate HCL for pools in this range
		sb.WriteString("### Terraform Configuration\n\n")
		sb.WriteString("```hcl\n")
		sb.WriteString(generateHCLForRange(pools, poolsInRange))
		sb.WriteString("```\n\n")
	}

	return sb.String()
}

func generateHCLForRange(pools *PoolsConfig, poolsInRange []PoolInfo) string {
	var sb strings.Builder

	if pools == nil || len(poolsInRange) == 0 {
		return ""
	}

	// Sort by pool name for consistent output
	sortedPools := make([]PoolInfo, len(poolsInRange))
	copy(sortedPools, poolsInRange)
	sort.Slice(sortedPools, func(i, j int) bool {
		return sortedPools[i].Name < sortedPools[j].Name
	})

	for _, info := range sortedPools {
		poolDef, exists := pools.GetPool(info.Name)
		if !exists || len(poolDef.CIDR) == 0 {
			continue
		}

		// Determine block_size from CIDR
		_, pNet, _ := net.ParseCIDR(info.CIDR)
		ones, _ := pNet.Mask.Size()

		// Determine private_range
		privateRange := "class_a"
		if strings.HasPrefix(info.CIDR, "172.") {
			privateRange = "class_b"
		} else if strings.HasPrefix(info.CIDR, "192.168.") {
			privateRange = "class_c"
		}

		sb.WriteString(fmt.Sprintf("resource \"ipam_pool\" %q {\n", info.Name))
		sb.WriteString(fmt.Sprintf("  name          = %q\n", info.Name))
		sb.WriteString(fmt.Sprintf("  description   = %q\n", poolDef.Description))
		sb.WriteString(fmt.Sprintf("  private_range = %q\n", privateRange))
		sb.WriteString(fmt.Sprintf("  block_size    = %d\n", ones))
		if poolDef.Reserved {
			sb.WriteString("  reserved      = true\n")
		}
		if len(poolDef.Metadata) > 0 {
			sb.WriteString("  metadata = {\n")
			var metaKeys []string
			for k := range poolDef.Metadata {
				metaKeys = append(metaKeys, k)
			}
			sort.Strings(metaKeys)
			for _, k := range metaKeys {
				sb.WriteString(fmt.Sprintf("    %s = %q\n", k, poolDef.Metadata[k]))
			}
			sb.WriteString("  }\n")
		}
		sb.WriteString("}\n\n")
	}

	return sb.String()
}

// Block represents a block in the address space.
type Block struct {
	CIDR        string
	StartIP     string
	EndIP       string
	Size        uint64
	Type        string // "pool", "available"
	Name        string
	PoolName    string
	Utilization float64 // 0-100 for pools
	UsedAddrs   uint64  // allocated addresses
	Link        string
	Metadata    map[string]string
}

func (b *Block) ToTableRow() string {
	sizeStr := formatNumber(b.Size)
	cidrWithRange := fmt.Sprintf("`%s` (%s - %s)", b.CIDR, b.StartIP, b.EndIP)

	var status, poolName, allocated, util string
	switch b.Type {
	case "pool":
		status = "üîµ&nbsp;&nbsp;Allocated"
		poolName = fmt.Sprintf("[%s](%s)", b.Name, b.Link)
		allocated = fmt.Sprintf("%s/%s (%.1f%%)", formatNumber(b.UsedAddrs), formatNumber(b.Size), b.Utilization)
		util = renderUtilBarOnly(b.Utilization)
	case "reserved":
		status = "üü†&nbsp;&nbsp;Reserved"
		if b.Link != "" {
			// Reserved pool (has detail page)
			poolName = fmt.Sprintf("[%s](%s)", b.Name, b.Link)
		} else {
			// Reserved allocation within a pool
			poolName = b.Name
		}
		allocated = "‚Äî"
		util = "‚Äî"
	default: // available
		status = "‚ö™&nbsp;&nbsp;Available"
		poolName = "‚Äî"
		allocated = "‚Äî"
		util = "‚Äî"
	}

	return fmt.Sprintf("| %s | %s | %s | %s | %s | %s |\n",
		status, poolName, cidrWithRange, sizeStr, allocated, util)
}

func toTitleCase(s string) string {
	// Replace hyphens and underscores with spaces, then title case each word
	s = strings.ReplaceAll(s, "-", " ")
	s = strings.ReplaceAll(s, "_", " ")
	words := strings.Fields(s)
	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(string(word[0])) + strings.ToLower(word[1:])
		}
	}
	return strings.Join(words, " ")
}

func renderUtilBarOnly(pct float64) string {
	filled := int(pct / 10)
	if filled > 10 {
		filled = 10
	}
	if filled < 1 && pct > 0 {
		filled = 1
	}
	return strings.Repeat("‚ñà", filled) + strings.Repeat("‚ñë", 10-filled)
}

func buildRangeBlocks(pr PrivateRange, poolsInRange []PoolInfo, pools *PoolsConfig, allocations *AllocationsDatabase) []Block {
	var blocks []Block

	_, rangeNet, _ := net.ParseCIDR(pr.CIDR)
	rangeStart := ipToUint32(rangeNet.IP)
	rangeEnd := rangeStart + uint32(pr.TotalAddrs)

	// Build list of pool ranges
	type poolRange struct {
		start uint32
		end   uint32
		info  PoolInfo
	}
	var poolRanges []poolRange
	for _, p := range poolsInRange {
		_, pNet, _ := net.ParseCIDR(p.CIDR)
		pStart := ipToUint32(pNet.IP)
		pSize := cidrToAddresses(p.CIDR)
		poolRanges = append(poolRanges, poolRange{
			start: pStart,
			end:   pStart + uint32(pSize),
			info:  p,
		})
	}

	// Sort by start address
	sort.Slice(poolRanges, func(i, j int) bool {
		return poolRanges[i].start < poolRanges[j].start
	})

	current := rangeStart
	for _, pr := range poolRanges {
		// Available space before this pool
		if pr.start > current {
			blocks = append(blocks, makeAvailableBlock(current, pr.start))
		}

		// The pool itself
		blocks = append(blocks, makePoolBlock(pr.info, pools, allocations))
		current = pr.end
	}

	// Available space at the end
	if current < rangeEnd {
		blocks = append(blocks, makeAvailableBlock(current, rangeEnd))
	}

	return blocks
}

func makeAvailableBlock(start, end uint32) Block {
	size := end - start
	cidr := findBestCIDR(start, size)
	return Block{
		CIDR:    cidr,
		StartIP: uint32ToIP(start),
		EndIP:   uint32ToIP(end - 1),
		Size:    uint64(size),
		Type:    "available",
	}
}

func makePoolBlock(info PoolInfo, pools *PoolsConfig, allocations *AllocationsDatabase) Block {
	_, pNet, _ := net.ParseCIDR(info.CIDR)
	pStart := ipToUint32(pNet.IP)
	pSize := cidrToAddresses(info.CIDR)

	// Check if pool is reserved and get metadata
	blockType := "pool"
	var metadata map[string]string
	if poolDef, exists := pools.GetPool(info.Name); exists {
		if poolDef.Reserved {
			blockType = "reserved"
		}
		metadata = poolDef.Metadata
	}

	// Calculate utilization
	var usedAddrs uint64
	if allocations != nil {
		for _, alloc := range allocations.GetAllocationsForPool(info.Name) {
			if alloc.ParentCIDR == nil {
				usedAddrs += cidrToAddresses(alloc.CIDR)
			}
		}
	}
	util := 0.0
	if pSize > 0 {
		util = float64(usedAddrs) / float64(pSize) * 100
	}

	return Block{
		CIDR:        info.CIDR,
		StartIP:     uint32ToIP(pStart),
		EndIP:       uint32ToIP(pStart + uint32(pSize) - 1),
		Size:        pSize,
		Type:        blockType,
		Name:        info.Name,
		PoolName:    info.Name,
		Utilization: util,
		UsedAddrs:   usedAddrs,
		Link:        fmt.Sprintf("ipam/pools/%s.md", info.Name),
		Metadata:    metadata,
	}
}

func generatePoolPage(poolName string, pools *PoolsConfig, allocations *AllocationsDatabase) string {
	var sb strings.Builder

	poolDef, exists := pools.GetPool(poolName)
	if !exists {
		return fmt.Sprintf("# Pool: %s\n\n*Pool not found*\n", poolName)
	}

	cidr := ""
	if len(poolDef.CIDR) > 0 {
		cidr = poolDef.CIDR[0]
	}

	sb.WriteString(fmt.Sprintf("# %s\n\n", poolName))
	sb.WriteString("> ‚ö†Ô∏è&nbsp;&nbsp;**IMPORTANT**&nbsp;&nbsp;‚ö†Ô∏è<br>\n")
	sb.WriteString(">\n")
	sb.WriteString("> This documentation is automatically generated by the `easytofu/github-ipam` Terraform provider. Do not manually edit\n")
	sb.WriteString("> this page, changes will be overwritten when allocations are updated. For more information please view the Terraform\n")
	sb.WriteString("> provider registry at: https://registry.terraform.io/providers/easytofu/github-ipam/latest/docs\n\n")
	sb.WriteString("[‚Üê Back to Overview](../README.md)\n\n")

	if poolDef.Reserved {
		sb.WriteString("> üü† **RESERVED** ‚Äî This pool is reserved for future use. Allocations are not permitted.\n\n")
	}

	if poolDef.Description != "" {
		sb.WriteString(fmt.Sprintf("*%s*\n\n", poolDef.Description))
	}

	// Pool info
	poolSize := cidrToAddresses(cidr)
	_, pNet, _ := net.ParseCIDR(cidr)
	pStart := ipToUint32(pNet.IP)
	rangeStart := uint32ToIP(pStart)
	rangeEnd := uint32ToIP(pStart + uint32(poolSize) - 1)

	// Get allocations
	var poolAllocs []Allocation
	if allocations != nil {
		poolAllocs = allocations.GetAllocationsForPool(poolName)
	}

	// Calculate stats
	var usedAddrs uint64
	for _, alloc := range poolAllocs {
		if alloc.ParentCIDR == nil {
			usedAddrs += cidrToAddresses(alloc.CIDR)
		}
	}
	util := 0.0
	if poolSize > 0 {
		util = float64(usedAddrs) / float64(poolSize) * 100
	}

	sb.WriteString("## Overview\n\n")
	sb.WriteString("| Property | Value |\n")
	sb.WriteString("|:---------|:------|\n")
	sb.WriteString(fmt.Sprintf("| Pool Name | %s |\n", poolName))
	sb.WriteString(fmt.Sprintf("| CIDR | `%s` (%s - %s) |\n", cidr, rangeStart, rangeEnd))
	sb.WriteString(fmt.Sprintf("| Total Addresses | %s |\n", formatNumber(poolSize)))
	sb.WriteString(fmt.Sprintf("| Allocated | %s/%s (%.1f%%) |\n", formatNumber(usedAddrs), formatNumber(poolSize), util))
	// Add metadata items as rows
	if len(poolDef.Metadata) > 0 {
		var metaKeys []string
		for k := range poolDef.Metadata {
			metaKeys = append(metaKeys, k)
		}
		sort.Strings(metaKeys)
		for _, k := range metaKeys {
			sb.WriteString(fmt.Sprintf("| %s | %s |\n", toTitleCase(k), poolDef.Metadata[k]))
		}
	}
	sb.WriteString("\n")

	// Allocations table
	sb.WriteString("## Allocations\n\n")

	if len(poolAllocs) == 0 {
		sb.WriteString("*No allocations yet*\n\n")
	} else {
		// Sort allocations
		sort.Slice(poolAllocs, func(i, j int) bool {
			return compareCIDRs(poolAllocs[i].CIDR, poolAllocs[j].CIDR)
		})

		sb.WriteString("| Status | Name | CIDR | Addresses |\n")
		sb.WriteString("|:-------|:-----|:-----|----------:|\n")

		for _, alloc := range poolAllocs {
			status := "üîµ&nbsp;&nbsp;Allocated"
			if alloc.Reserved {
				status = "üü†&nbsp;&nbsp;Reserved"
			}
			_, aNet, _ := net.ParseCIDR(alloc.CIDR)
			aStart := ipToUint32(aNet.IP)
			aSize := cidrToAddresses(alloc.CIDR)
			cidrWithRange := fmt.Sprintf("`%s` (%s - %s)", alloc.CIDR, uint32ToIP(aStart), uint32ToIP(aStart+uint32(aSize)-1))
			sb.WriteString(fmt.Sprintf("| %s | %s | %s | %s |\n",
				status, alloc.Name, cidrWithRange, formatNumber(aSize)))
		}
		sb.WriteString("\n")
	}

	// Generate HCL for allocations in this pool
	sb.WriteString("## Terraform Configuration\n\n")
	sb.WriteString("```hcl\n")
	sb.WriteString(generatePoolAllocationHCL(poolName, poolAllocs))
	sb.WriteString("```\n")

	return sb.String()
}

func generatePoolAllocationHCL(poolName string, allocs []Allocation) string {
	var sb strings.Builder

	for _, alloc := range allocs {
		// Skip subnets (child allocations)
		if alloc.ParentCIDR != nil {
			continue
		}

		// Create a safe resource name
		resourceName := strings.ReplaceAll(alloc.Name, " ", "_")
		resourceName = strings.ReplaceAll(resourceName, "-", "_")
		resourceName = strings.ReplaceAll(resourceName, "(", "")
		resourceName = strings.ReplaceAll(resourceName, ")", "")
		resourceName = strings.ToLower(resourceName)

		// Determine block_size from CIDR
		_, aNet, _ := net.ParseCIDR(alloc.CIDR)
		ones, _ := aNet.Mask.Size()

		status := "allocation"
		if alloc.Reserved {
			status = "reservation"
		}

		sb.WriteString(fmt.Sprintf("resource \"ipam_allocation\" %q {\n", resourceName))
		sb.WriteString(fmt.Sprintf("  name       = %q\n", alloc.Name))
		sb.WriteString(fmt.Sprintf("  pool       = %q\n", poolName))
		sb.WriteString(fmt.Sprintf("  block_size = %d\n", ones))
		sb.WriteString(fmt.Sprintf("  status     = %q\n", status))
		if len(alloc.Metadata) > 0 {
			sb.WriteString("  metadata = {\n")
			var metaKeys []string
			for k := range alloc.Metadata {
				metaKeys = append(metaKeys, k)
			}
			sort.Strings(metaKeys)
			for _, k := range metaKeys {
				sb.WriteString(fmt.Sprintf("    %s = %q\n", k, alloc.Metadata[k]))
			}
			sb.WriteString("  }\n")
		}
		sb.WriteString("}\n\n")
	}

	if sb.Len() == 0 {
		return "# No allocations in this pool\n"
	}

	return sb.String()
}

// PoolInfo holds pool information for sorting.
type PoolInfo struct {
	Name string
	CIDR string
}

func getPoolsInRange(pools *PoolsConfig, rangeCIDR string) []PoolInfo {
	if pools == nil || pools.Pools == nil {
		return nil
	}

	_, rangeNet, err := net.ParseCIDR(rangeCIDR)
	if err != nil {
		return nil
	}

	var result []PoolInfo
	for name, pool := range pools.Pools {
		for _, cidr := range pool.CIDR {
			_, poolNet, err := net.ParseCIDR(cidr)
			if err != nil {
				continue
			}
			if rangeNet.Contains(poolNet.IP) {
				result = append(result, PoolInfo{Name: name, CIDR: cidr})
			}
		}
	}

	sort.Slice(result, func(i, j int) bool {
		return compareCIDRs(result[i].CIDR, result[j].CIDR)
	})

	return result
}

func cidrToAddresses(cidr string) uint64 {
	_, network, err := net.ParseCIDR(cidr)
	if err != nil {
		return 0
	}
	ones, bits := network.Mask.Size()
	return uint64(1) << (bits - ones)
}

func formatNumber(n uint64) string {
	// Format with thousands separators
	s := fmt.Sprintf("%d", n)
	// Add commas for thousands
	var result []byte
	for i, c := range s {
		if i > 0 && (len(s)-i)%3 == 0 {
			result = append(result, ',')
		}
		result = append(result, byte(c))
	}
	return string(result)
}

func compareCIDRs(a, b string) bool {
	ipA, _, _ := net.ParseCIDR(a)
	ipB, _, _ := net.ParseCIDR(b)
	if ipA == nil || ipB == nil {
		return a < b
	}
	return ipToUint32(ipA) < ipToUint32(ipB)
}

// ipToUint32 is defined in pools.go (shared in ipam package)

func uint32ToIP(n uint32) string {
	return fmt.Sprintf("%d.%d.%d.%d",
		(n>>24)&0xFF,
		(n>>16)&0xFF,
		(n>>8)&0xFF,
		n&0xFF)
}

func findBestCIDR(start, size uint32) string {
	if size == 0 {
		return ""
	}

	// For display purposes, show the range as start-end/prefix
	// Find largest prefix that fits
	prefixLen := 32
	for s := size; s > 1; s >>= 1 {
		prefixLen--
	}

	// Check alignment
	blockSize := uint32(1) << (32 - prefixLen)
	if start%blockSize != 0 || blockSize > size {
		// Not aligned or too big, just show the range
		return fmt.Sprintf("%s‚Äî%s", uint32ToIP(start), uint32ToIP(start+size-1))
	}

	return fmt.Sprintf("%s/%d", uint32ToIP(start), prefixLen)
}

// GenerateREADME generates just the main README (for backwards compatibility).
func GenerateREADME(pools *PoolsConfig, allocations *AllocationsDatabase) string {
	return generateMainREADME(pools, allocations)
}
