// Copyright (c) EasyTofu
// SPDX-License-Identifier: MPL-2.0

package ipam

import (
	"fmt"
	"net"
	"sort"
	"strings"
	"time"
)

// PrivateRange represents a private IP address range.
type PrivateRange struct {
	Name        string
	CIDR        string
	Description string
	TotalAddrs  uint64
}

// Private IP ranges (RFC 1918)
var PrivateRanges = []PrivateRange{
	{Name: "Class A", CIDR: "10.0.0.0/8", Description: "10.0.0.0 - 10.255.255.255", TotalAddrs: 16777216},
	{Name: "Class B", CIDR: "172.16.0.0/12", Description: "172.16.0.0 - 172.31.255.255", TotalAddrs: 1048576},
	{Name: "Class C", CIDR: "192.168.0.0/16", Description: "192.168.0.0 - 192.168.255.255", TotalAddrs: 65536},
}

// CIDRBlock represents a CIDR block with metadata.
type CIDRBlock struct {
	CIDR       string
	Name       string
	Type       string // "pool", "allocation", "available"
	Addresses  uint64
	PoolID     string
	ParentCIDR string
}

// GenerateREADME generates a markdown README showing IPAM status.
func GenerateREADME(pools *PoolsConfig, allocations *AllocationsDatabase) string {
	var sb strings.Builder

	sb.WriteString("# IP Address Management\n\n")
	sb.WriteString("> Auto-generated by terraform-provider-github-ipam\n>\n")
	sb.WriteString(fmt.Sprintf("> Last updated: %s\n\n", time.Now().UTC().Format("2006-01-02 15:04:05 UTC")))

	// Process each private range
	for _, pr := range PrivateRanges {
		poolsInRange := getPoolsInRange(pools, pr.CIDR)
		if len(poolsInRange) == 0 {
			continue
		}

		sb.WriteString(fmt.Sprintf("## %s (%s)\n\n", pr.Name, pr.CIDR))
		sb.WriteString(fmt.Sprintf("*%s*\n\n", pr.Description))

		// Calculate statistics
		stats := calculateRangeStats(pr, poolsInRange, allocations)
		sb.WriteString(fmt.Sprintf("| Metric | Value |\n"))
		sb.WriteString(fmt.Sprintf("|--------|-------|\n"))
		sb.WriteString(fmt.Sprintf("| Total Addresses | %s |\n", formatNumber(pr.TotalAddrs)))
		sb.WriteString(fmt.Sprintf("| Allocated to Pools | %s |\n", formatNumber(stats.PoolAddrs)))
		sb.WriteString(fmt.Sprintf("| Used by Allocations | %s |\n", formatNumber(stats.AllocAddrs)))
		sb.WriteString(fmt.Sprintf("| Available in Pools | %s |\n", formatNumber(stats.PoolAddrs-stats.AllocAddrs)))
		sb.WriteString(fmt.Sprintf("| Unassigned | %s |\n\n", formatNumber(pr.TotalAddrs-stats.PoolAddrs)))

		// Show pools
		for _, pool := range poolsInRange {
			sb.WriteString(fmt.Sprintf("### Pool: `%s`\n\n", pool.Name))

			poolDef := pools.Pools[pool.Name]
			if poolDef.Description != "" {
				sb.WriteString(fmt.Sprintf("*%s*\n\n", poolDef.Description))
			}

			// Pool CIDR info
			poolAddrs := cidrToAddresses(pool.CIDR)
			sb.WriteString(fmt.Sprintf("**CIDR:** `%s` (%s addresses)\n\n", pool.CIDR, formatNumber(poolAddrs)))

			// Get allocations for this pool
			poolAllocs := allocations.GetAllocationsForPool(pool.Name)

			if len(poolAllocs) == 0 {
				sb.WriteString("*No allocations*\n\n")
				continue
			}

			// Sort allocations by CIDR
			sort.Slice(poolAllocs, func(i, j int) bool {
				return compareCIDRs(poolAllocs[i].CIDR, poolAllocs[j].CIDR)
			})

			// Show allocations table
			sb.WriteString("| CIDR | Name | Addresses | Type |\n")
			sb.WriteString("|------|------|-----------|------|\n")

			for _, alloc := range poolAllocs {
				allocType := "VPC"
				if alloc.ParentCIDR != nil {
					allocType = "Subnet"
				}
				addrs := cidrToAddresses(alloc.CIDR)
				sb.WriteString(fmt.Sprintf("| `%s` | %s | %s | %s |\n",
					alloc.CIDR, alloc.Name, formatNumber(addrs), allocType))
			}
			sb.WriteString("\n")

			// Show available ranges
			availableRanges := findAvailableRanges(pool.CIDR, poolAllocs)
			if len(availableRanges) > 0 {
				sb.WriteString("<details>\n<summary>Available ranges</summary>\n\n")
				sb.WriteString("| CIDR | Addresses |\n")
				sb.WriteString("|------|----------|\n")
				for _, ar := range availableRanges {
					sb.WriteString(fmt.Sprintf("| `%s` | %s |\n", ar.CIDR, formatNumber(ar.Addresses)))
				}
				sb.WriteString("\n</details>\n\n")
			}
		}

		sb.WriteString("---\n\n")
	}

	return sb.String()
}

// RangeStats holds statistics for a private range.
type RangeStats struct {
	PoolAddrs  uint64
	AllocAddrs uint64
}

// PoolInfo holds pool information for sorting.
type PoolInfo struct {
	Name string
	CIDR string
}

func getPoolsInRange(pools *PoolsConfig, rangeCIDR string) []PoolInfo {
	if pools == nil || pools.Pools == nil {
		return nil
	}

	_, rangeNet, err := net.ParseCIDR(rangeCIDR)
	if err != nil {
		return nil
	}

	var result []PoolInfo
	for name, pool := range pools.Pools {
		for _, cidr := range pool.CIDR {
			_, poolNet, err := net.ParseCIDR(cidr)
			if err != nil {
				continue
			}
			// Check if pool is within this range
			if rangeNet.Contains(poolNet.IP) {
				result = append(result, PoolInfo{Name: name, CIDR: cidr})
			}
		}
	}

	// Sort by CIDR
	sort.Slice(result, func(i, j int) bool {
		return compareCIDRs(result[i].CIDR, result[j].CIDR)
	})

	return result
}

func calculateRangeStats(pr PrivateRange, poolsInRange []PoolInfo, allocations *AllocationsDatabase) RangeStats {
	var stats RangeStats

	for _, pool := range poolsInRange {
		stats.PoolAddrs += cidrToAddresses(pool.CIDR)

		if allocations != nil {
			for _, alloc := range allocations.GetAllocationsForPool(pool.Name) {
				// Only count top-level allocations (not subnets)
				if alloc.ParentCIDR == nil {
					stats.AllocAddrs += cidrToAddresses(alloc.CIDR)
				}
			}
		}
	}

	return stats
}

func cidrToAddresses(cidr string) uint64 {
	_, network, err := net.ParseCIDR(cidr)
	if err != nil {
		return 0
	}
	ones, bits := network.Mask.Size()
	return uint64(1) << (bits - ones)
}

func formatNumber(n uint64) string {
	if n >= 1000000 {
		return fmt.Sprintf("%.1fM", float64(n)/1000000)
	}
	if n >= 1000 {
		return fmt.Sprintf("%.1fK", float64(n)/1000)
	}
	return fmt.Sprintf("%d", n)
}

func compareCIDRs(a, b string) bool {
	ipA, _, _ := net.ParseCIDR(a)
	ipB, _, _ := net.ParseCIDR(b)
	if ipA == nil || ipB == nil {
		return a < b
	}
	return ipToUint32(ipA) < ipToUint32(ipB)
}

func ipToUint32(ip net.IP) uint32 {
	ip = ip.To4()
	if ip == nil {
		return 0
	}
	return uint32(ip[0])<<24 | uint32(ip[1])<<16 | uint32(ip[2])<<8 | uint32(ip[3])
}

// AvailableRange represents an available CIDR range.
type AvailableRange struct {
	CIDR      string
	Addresses uint64
}

func findAvailableRanges(poolCIDR string, allocations []Allocation) []AvailableRange {
	_, poolNet, err := net.ParseCIDR(poolCIDR)
	if err != nil {
		return nil
	}

	poolStart := ipToUint32(poolNet.IP)
	ones, bits := poolNet.Mask.Size()
	poolSize := uint32(1) << (bits - ones)
	poolEnd := poolStart + poolSize

	// Collect all used ranges (top-level allocations only)
	var usedRanges [][2]uint32
	for _, alloc := range allocations {
		if alloc.ParentCIDR != nil {
			continue // Skip sub-allocations
		}
		_, allocNet, err := net.ParseCIDR(alloc.CIDR)
		if err != nil {
			continue
		}
		allocStart := ipToUint32(allocNet.IP)
		allocOnes, allocBits := allocNet.Mask.Size()
		allocSize := uint32(1) << (allocBits - allocOnes)
		usedRanges = append(usedRanges, [2]uint32{allocStart, allocStart + allocSize})
	}

	// Sort by start address
	sort.Slice(usedRanges, func(i, j int) bool {
		return usedRanges[i][0] < usedRanges[j][0]
	})

	// Find gaps
	var available []AvailableRange
	current := poolStart

	for _, used := range usedRanges {
		if used[0] > current {
			// There's a gap
			gapSize := used[0] - current
			gapCIDR := findLargestCIDR(current, gapSize)
			if gapCIDR != "" {
				available = append(available, AvailableRange{
					CIDR:      gapCIDR,
					Addresses: uint64(gapSize),
				})
			}
		}
		if used[1] > current {
			current = used[1]
		}
	}

	// Check for space at the end
	if current < poolEnd {
		gapSize := poolEnd - current
		gapCIDR := findLargestCIDR(current, gapSize)
		if gapCIDR != "" {
			available = append(available, AvailableRange{
				CIDR:      gapCIDR,
				Addresses: uint64(gapSize),
			})
		}
	}

	return available
}

func findLargestCIDR(start, size uint32) string {
	if size == 0 {
		return ""
	}

	// Find the largest power of 2 that fits
	prefixLen := 32
	for s := size; s > 1; s >>= 1 {
		prefixLen--
	}

	// Ensure alignment
	blockSize := uint32(1) << (32 - prefixLen)
	if start%blockSize != 0 {
		// Not aligned, use a smaller block
		for prefixLen < 32 {
			prefixLen++
			blockSize = uint32(1) << (32 - prefixLen)
			if start%blockSize == 0 && blockSize <= size {
				break
			}
		}
	}

	ip := uint32ToIP(start)
	return fmt.Sprintf("%s/%d", ip, prefixLen)
}

func uint32ToIP(n uint32) string {
	return fmt.Sprintf("%d.%d.%d.%d",
		(n>>24)&0xFF,
		(n>>16)&0xFF,
		(n>>8)&0xFF,
		n&0xFF)
}
